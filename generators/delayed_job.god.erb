# == God config file for delayed_job
#
# http://god.rubyforge.org/
# Original config taken from: http://def-end.com/post/10440978748/god-config-for-delayed-job
# Modified by Romain Champourlier (romain@softr.li)
#
# God config file generator for delayed_job to be used with Capistrano to deploy apps
# with God monitoring.
#
# REFERENCES
#   - Useful documentation on script/delayed_job:
#     https://github.com/collectiveidea/delayed_job/wiki/Delayed-job-command-details
#
# CONVENTIONS
#
# `pids_path` must be set to tell God where the PID files can be found.
# The PID file is expected to follow this convention:
#   <pids_path>/delayed_job.<index>.pid
#
CURRENT_DIR = "<%= current_path %>"
SHARED_DIR = "<%= shared_path %>"
LOG_DIR = "<%= log_path %>"
PIDS_DIR = "<%= pids_path %>"
CMD = "bundle exec script/delayed_job"

<%= background_workers %>.times do |index|

  God.watch do |w|
    w.dir = "<%= current_path %>"

    w.group = "<%= application %>"
    w.name = w.group + "-delayed-job-#{index}"
    
    w.uid = '<%= user %>'
    w.gid = '<%= group %>'
 
    w.start = "#{CMD} start -i #{index} -e #{rails_env}"
    w.start_grace = 30.seconds 
    w.restart_grace = 30.seconds 

    w.stop = "#{CMD} stop" 
    
    w.log = "#{LOG_DIR}/god_delayed_job.#{index}.log" 
    w.pid_file = "#{PIDS_DIR}/delayed_job.#{index}.pid"

    w.interval = 15.seconds 
    w.behavior(:clean_pid_file) 

    w.start_if do |start| 
      start.condition(:process_running) do |c| 
        c.interval = 5.seconds 
        c.running = false 
      end 
    end 

    w.restart_if do |restart| 
      restart.condition(:memory_usage) do |c| 
        c.above = 300.megabytes 
        c.times = [3, 5] # 3 out of 5 intervals 
      end 

      restart.condition(:cpu_usage) do |c| 
        c.above = 50.percent 
        c.times = 5 
      end 
    end 

    # lifecycle 
    w.lifecycle do |on| 
      on.condition(:flapping) do |c| 
        c.to_state = [:start, :restart] 
        c.times = 5 
        c.within = 5.minute 
        c.transition = :unmonitored 
        c.retry_in = 10.minutes 
        c.retry_times = 5 
        c.retry_within = 2.hours 
      end 
    end 

    # determine the state on startup
    w.transition(:init, { true => :up, false => :start }) do |on|
      on.condition(:process_running) do |c|
        c.running = true
      end
    end
 
    # determine when process has finished starting
    w.transition([:start, :restart], :up) do |on|
      on.condition(:process_running) do |c|
        c.running = true
        c.interval = 5.seconds
      end
 
      # failsafe
      on.condition(:tries) do |c|
        c.times = 5
        c.transition = :start
        c.interval = 5.seconds
      end
    end
 
    # start if process is not running
    w.transition(:up, :start) do |on|
      on.condition(:process_running) do |c|
        c.running = false
      end
    end
  end
end